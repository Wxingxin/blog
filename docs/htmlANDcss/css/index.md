#  CSS

### 是什么

1. 比较好的回答是：其实并不存在真正意义上的 CSS3，因为我有阅读 W3C 的文档。

- 从 CSS3 并不是一个**单一**的规范，而是**一系列**独立**模块**的集合，这些模块扩展了 CSS 的功能。
- 这种模块化的 **发展方法** 允许 **不同的特性** 以 **不同的速度** 发展，可以更快的**标准化**一些特性，而不必等待 **整个规范** 的完成。

### **举例子**

1️⃣ 选择器（Selectors）：

- 新的属性选择器，如`[attr^=value]`（属性值以特定字符串开始）；
- 结构性伪类,如:nth-child、:nth-last-child、:first-of-type ;

2️⃣ 背景和边框（Backgrounds and Borders）：

- 边框图片（border-image），允许使用图片来创建边框。
- 多重背景，支持在单个元素上使用多个背景图片。

3️⃣ 文本效果（Text Effects）：

- 文本阴影（text-shadow），可以在文字后面添加阴影效果。
- 文本溢出（text-overflow），控制文本溢出容器时的显示方式。

4️⃣ 转换和动画（CSS Transforms Module,CSS Animations ）:

- 2D 和 3D 转换（transform），包括旋转（~rotate）、缩放（scale）、倾斜（skew）和平移（^translate）。
- CSS 动画（animation），允许定义关键帧动画，控制动画序列。

# 💯💯💯 css 的单位 ⏸ 像素 ⏸ 选择器

> ### **CSS 单位有哪些？px、em、rem、%、vh/vw 区别？**

###### 1️⃣ 绝对单位

- px：绝对单位
- `mm,cm,pc,pt` :打印用

###### 2️⃣ 相对单位

- em：相对父元素**字体**大小
- rem：相对根元素**字体**大小

###### 3️⃣ 比例

- %：相对父元素宽/高

###### 4️⃣ 视口

| 单位   | 含义                     | 举例               |
| ------ | ------------------------ | ------------------ |
| `vw`   | 1vw = 视口宽度的 1%      | 100vw = 视口宽度   |
| `vh`   | 1vh = 视口高度的 1%      | 100vh = 视口高度   |
| `vmin` | 取 `vw` 与 `vh` 中较小者 | 保证元素能完整显示 |
| `vmax` | 取 `vw` 与 `vh` 中较大者 | 保证充满较大方向   |

###### 🔀

| 函数      | 作用           | 举例                                 |
| --------- | -------------- | ------------------------------------ |
| `calc()`  | 动态计算长度值 | `width: calc(100% - 50px);`          |
| `clamp()` | 限制范围       | `font-size: clamp(1rem, 2vw, 2rem);` |
| `min()`   | 取最小值       | `width: min(90vw, 600px);`           |
| `max()`   | 取最大值       | `width: max(50%, 300px);`            |

> ### 说说设备像素，css 像素，设备独立像素，dpr，ppi 之间的区别

##### 物理像素（Physical Pixel）也称为设备像素，是显示屏幕的最小物理单位。

- 每个物理像素可以发光并显示特定的颜色
- 物理像素的大小是固定的，由设备的硬件决定。
- 比如 iPhone 15 Pro Max 的分辨率 1290× 2796，指的就是物理像素;
- 物理像素的密度（每英寸像素数量，即 PPI，英语：PixelsPerInch，缩写：PPI）
- √PPI 越高，屏幕显示的内容就越细腻。
- √ 1 英寸=2.54 厘米，在工业领域被广泛应用

##### 逻辑像素（Logical Pixel），有时也被称为设备独立像素（Device IndependentPixel，简称 DiP）

- 是一个抽象的单位，用于在编程中统一不同设备的显示标准。
- 逻辑像素是用来衡量在不同设备上如何统一显示内容的尺寸单位。
- 例如，在高分辨率设备上，可能有多个物理像素组成一个逻辑像素。
- 这样，无论设备的物理像素密度如何，使用逻辑像素单位开发的界面都能保持相对一致的大小和视觉效果。

> ### CSS 像素-DPI-PPI

### 设备像素、CSS 像素、设备独立像素、DPR 和 PPI 的区别

在网页开发和屏幕显示领域，这些概念主要用于处理不同设备的分辨率和显示效果，确保内容在各种屏幕（如手机、电脑）上的一致性。下面我先简要解释每个术语，然后用表格总结它们的区别和关系。这些概念源于像素密度和设备适配的需求，尤其在高分辨率（Retina）屏幕普及后变得重要。

- **设备像素（Device Pixels）**：也称物理像素，是屏幕硬件上的实际最小显示单元。例如，一块屏幕的分辨率是 1920x1080，就意味着它有 1920x1080 个设备像素。它们是真实的硬件点，不能改变。
- **CSS 像素（CSS Pixels）**：CSS 样式表中使用的逻辑像素单位（如 width: 100px）。它不是固定大小，而是抽象的，浏览器会根据设备特性缩放以保持布局一致性。在标准屏幕上，1 CSS 像素 ≈ 1 设备像素，但高 DPR 设备上会不同。

- **设备独立像素（Device-Independent Pixels, DIP）**：也称密度独立像素（Density-Independent Pixels），是一种抽象单位，用于确保在不同像素密度的设备上，UI 元素的大小看起来一致。Android 系统常用 DIP（或 dp），而 iOS 用点（points）。它与 CSS 像素类似，常用于移动开发。

- **DPR（Device Pixel Ratio）**：设备像素比率，即设备像素与 CSS 像素的比率。例如，DPR=2 意味着 1 个 CSS 像素对应 4 个设备像素（2x2）。它帮助浏览器决定如何渲染内容，以适应高分辨率屏幕（如 Retina 显示屏）。

- **PPI（Pixels Per Inch）**：每英寸像素数，衡量屏幕的像素密度（清晰度）。例如，PPI=300 表示每英寸有 300 个像素。高 PPI 屏幕更锐利，但需要更高的 DPR 来匹配软件渲染。

这些概念相互关联：DPR 和 PPI 描述硬件特性，而 CSS 像素和 DIP 是软件层面的抽象，帮助开发者创建响应式设计。

| 概念             | 定义                                                                         | 与其他概念的关系                                                            | 示例场景                                                                                 |
| ---------------- | ---------------------------------------------------------------------------- | --------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
| **设备像素**     | 屏幕硬件上的物理像素点，是实际的最小显示单元。                               | 是 DPR 的分子；PPI 基于设备像素计算。                                       | 一块 4K 屏幕有 3840x2160 设备像素，无论软件如何渲染，这些像素数量不变。                  |
| **CSS 像素**     | CSS 中使用的逻辑像素单位，用于布局和样式定义，由浏览器根据 DPR 缩放。        | 等于 DIP 在 Web 上下文；DPR = 设备像素 / CSS 像素。                         | 在 DPR=1 的屏幕上，width:100px 占用 100 设备像素；在 DPR=2 上占用 200 设备像素。         |
| **设备独立像素** | 密度独立的抽象像素单位，确保在不同密度屏幕上元素大小一致（常用于移动 App）。 | 与 CSS 像素类似或等价；忽略 PPI 差异，通过 DPR 转换到设备像素。             | Android 中 1dp 在低 PPI 屏幕上可能对应 1 设备像素，在高 PPI 上对应更多，以保持物理大小。 |
| **DPR**          | 设备像素与 CSS 像素的比率，用于高分辨率屏幕的渲染适配。                      | 基于 PPI 计算（高 PPI 通常对应高 DPR）；直接影响 CSS 像素到设备像素的映射。 | iPhone Retina 屏 DPR=2，意味着图像需 2x 分辨率以避免模糊。                               |
| **PPI**          | 每英寸的像素密度，衡量屏幕清晰度。                                           | 高 PPI 导致高 DPR；不直接影响软件层，但硬件基础决定 DPR。                   | 手机屏 PPI=400 比电脑屏 PPI=100 更清晰，但需 DPR 调整软件以匹配。                        |

> ### 🎯 一、CSS 权重的本质：四元组 (a, b, c, d)
>
> CSS 计算选择器的“权重”是为了决定哪条规则优先生效。

| 选择器类型                 | 示例                             | 权重值（A,B,C,D） |
| -------------------------- | -------------------------------- | ----------------- |
| 行内样式（Inline）         | `<div style="color:red">`        | 1,0,0,0           |
| ID 选择器                  | `#box`                           | 0,1,0,0           |
| 类选择器、属性选择器、伪类 | `.item`, `[type=text]`, `:hover` | 0,0,1,0           |
| 元素选择器、伪元素         | `div`, `p`, `::after`            | 0,0,0,1           |
| 通配选择器、继承、层叠     | `*`, 继承属性                    | 0,0,0,0           |

**比较时：**

- 从左到右比较（A,B,C,D）
- 数字越大权重越高
- 若相等，则后定义的规则生效（后写的覆盖前写的）

---

### 2. 特殊规则

- **内联样式** > **ID 选择器** > **类/伪类/属性** > **元素/伪元素**
- **`!important`** 不属于权重体系，它是“**终极优先级**”，但仍可被后一个相同层级的 `!important` 覆盖。
- **继承的样式权重为 0**
- **通配符（\*）的权重为 0**
- **组合选择器权重相加**
  例如：`div#app .title:hover` → `div(0,0,0,1)` + `#app(0,1,0,0)` + `.title(0,0,1,0)` + `:hover(0,0,1,0)` = **(0,1,2,1)**

> ### 🔹 案例 1：基础示例

```css
div {
  color: red;
}
.box {
  color: blue;
}
#main {
  color: green;
}
```

**计算：**

| 选择器  | 权重      | 说明     |
| ------- | --------- | -------- |
| `div`   | (0,0,0,1) | 一个元素 |
| `.box`  | (0,0,1,0) | 一个类   |
| `#main` | (0,1,0,0) | 一个 ID  |

🟢 **结果：绿色生效**，因为 ID 权重最高。

---

> ### 🔹 案例 2：多个选择器叠加

```css
#app .content p {
  color: blue;
}
```

**拆分：**

- `#app` → (0,1,0,0)
- `.content` → (0,0,1,0)
- `p` → (0,0,0,1)

**合计：**
(0,1,1,1)

---

> ### 🔹 案例 3：属性选择器的权重

```css
input[type="text"] {
  color: red;
}
input.text-input {
  color: blue;
}
```

**计算：**

| 选择器               | 权重      | 说明        |
| -------------------- | --------- | ----------- |
| `input[type="text"]` | (0,0,1,1) | 属性 + 元素 |
| `input.text-input`   | (0,0,1,1) | 类 + 元素   |

🟢 权重相同 → 后定义的生效。

---

> ### 🔹 案例 4：伪类的权重

```css
button:hover {
  color: red;
}
button:active {
  color: blue;
}
```

**计算：**

- `button:hover` → (0,0,1,1)
- `button:active` → (0,0,1,1)

权重相等 → **后写的生效**。

---

> ### 🔹 案例 5：伪元素的权重

```css
p::before {
  color: red;
}
p::after {
  color: blue;
}
```

伪元素属于“元素”类别 → (0,0,0,2)

👉 权重相同 → 后定义的生效。

---

> ### 🔹 案例 6：多层组合计算

```css
ul#nav li.active > a:hover {
  color: red;
}
```

分解：

- `ul` → (0,0,0,1)
- `#nav` → (0,1,0,0)
- `li.active` → (0,0,1,1)
- `a:hover` → (0,0,1,1)

加起来：
→ **(0,1,2,3)**

✅ 高权重组合（典型面试题）

---

> ### 🔹 案例 7：行内样式

```html
<p style="color:red;">文本</p>
```

行内样式 = (1,0,0,0)
✅ 无论 CSS 多复杂，都比外部 ID 选择器高。

---

> ### 🔹 案例 8：!important 决胜

```css
#app .title {
  color: red !important;
}
.title {
  color: blue !important;
}
```

两者都有 `!important` → 比权重：

- `#app .title` → (0,1,1,0)
- `.title` → (0,0,1,0)
  ✅ 红色生效。

> 🧠 小结：
>
> - `!important` 超越普通权重；
> - 但多个 `!important` 时仍需比较权重；
> - 行内样式若含 `!important`，是最强王者。

> ### 综合面试题 1

```css
div#main.content[data-role="box"] p.title strong::before
```

👉 权重是多少？

分解：

- `div` → (0,0,0,1)
- `#main` → (0,1,0,0)
- `.content` → (0,0,1,0)
- `[data-role="box"]` → (0,0,1,0)
- `p` → (0,0,0,1)
- `.title` → (0,0,1,0)
- `strong` → (0,0,0,1)
- `::before` → (0,0,0,1)

合计 = **(0,1,3,4)** ✅

> ### 综合面试题 1

```css
#app .a .b .c:hover p::after
```

→ 权重：(0,1,4,2)

---

> ### 综合面试题 1

`input[type=text]:focus` 和 `input.text:focus` 哪个更高？

都为：

- `input[type=text]:focus` → (0,0,2,1)
- `input.text:focus` → (0,0,2,1)
  ➡️ 权重相同，**后写的生效**。



# 💯💯💯 响应式与兼容性

> ### 响应式设计是什么？原理？

- 是什么 是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本

- 为什么 通过媒体查询检测不同设备屏幕尺寸做处理。

- 怎么触发 页面头部必须有 meta 声明 viewport

> ### 兼容性

为什么在移动端使用@2x @3x 的图片（移动端适配）
目前在移动端设备中，有非常多高分辨率的设备。为了适应不同的像素密度，UI 设计师通常需要为开发者提供多个版本的图像资源。
通常标记为@1x、@2x、@3× :
·@1x 图像：基本尺寸，适用于低分辨率设备。
@2x 图像：是基本图像尺寸的两倍，适用于中等分辨率设备，device-pixel-ratio 为 2 的设备。
@3x 图像：是基本图像尺寸的三倍，适用于高分辨率设备，device-pixel-ratio 为 3 的设备。
如果都使用的@1x 的图片，在高分辨率下就会图像非常模糊，模糊的图像可能会使产品显得粗糙，影响用户对应用品质的整体感觉。

我们开发 Web 可以通过媒体查询来设置不同的图像：

> ### 什么是 1px 问题，如何去解决，如何画出 0.5px 边框 (先进的浏览器 0.5px)

1. 我们知道在移动端的设计稿中，往往 UI 给的设计稿宽度为 750px，图中设计的边框宽度为 1px，在我们 375px 的设备下，我们应该将宽度写为 0.5px.
2. 但是如果直接设置 0.5 的话，一些设备（特别是旧的移动设备和浏览器）并且不支持 0.5px，这个就是我们常说的 1px 问题以及如何画出 0.5px 边框的问题。
3. 那么这种问题应该如何去处理呢？自前常见的方案有两种：

- 方案一：viewport+rem+ div（淘宝，大家可以自行了解）

##### 方案二：伪类+ transform（京东）

```html
<head>
  <title>Document</title>
  <style>
    .test {
      position: relative;
      display: inline-block;
      margin: 30px;
      padding: 8px;
    }
    .test::after {
      content: "";
      position: absolute;
      left: 0;
      right: 0;
      width: 200%;
      height: 200%;
      border: 1px solid red;
      transform: scale(0.5);
      transform-origin: top left;
    }
  </style>
</head>
<body>
  <div class="test">Hello World</div>
</body>
```

> ### 通常会采取哪些措施来确保网站或者应用在不同的浏览器上的兼容性

1. 可以从这几个角度来回答：不同的浏览器存在兼容性问题的核心原因是不同的浏览器可能使用的是不同的浏览器内核。
2. 其实在现代工程化的开发架构下，大多数的浏览器兼容性问题是可以通过工程化中的配置选项来解决的。

##### 遇到问题

1. 比如 browserslist 可以配置目标的浏览器或者 Node 环境，然后在不同的工具中起作用，比如 autoprefixer/babel/postcss-preset-env 等，在进行了正确的配置后，开发的 Vue 或者 React 项目在进行打包时，会自动根据目标环境来添加 CSS 前缀、Babel 代码转换等。
2. 如果我们想要额外的适配，通常在项目中我们还会引 I 入 normal.css 和 polyfils 来添加特定的 cSS、JS 的适配问题
3. 还有一些事针对移动端的，比如移动端点击 300ms 的延迟、移动端 1px 边框的问题，都可以在特定的环境或者需求下来解决
4. 当遇到问题时，很重要的事我们需要多查询 caniuse 的网站来确定某些特性的兼容性
5. 另外如果针对特定的用户使用的是不同的浏览器和设备时，我们需要使用特定的工具，比如 BrowserStack 这样的工具来进行测试遇到特定问题时，及时的解决和处理

##### 举一个具体的例子（越具体的例子，就越真实，越有说服力）：

1. 比如之前我们在开发中借助于 transform 实现动画效果，使用的是复合属性，transform:translate(10px,20px) scale(1.5);。
2. 但是这种复合属性在 IE11 上是有问题，因为它并不支持，所以我们就必须对它拆分属性，首先设置 translate，在它的外层再包裹一个容器，用来设置 scale 属性

# 💯💯💯 other

## 分析 css 代码阻塞怎么办

> ### 🧩 一、为什么 CSS 会阻塞？

浏览器渲染流程（关键点）：

1. 解析 HTML → 构建 DOM；
2. 解析 CSS → 构建 CSSOM；
3. DOM + CSSOM → Render Tree；
4. 再执行 JS、布局和绘制。

⚠️ 所以：

- **外部 CSS** 会阻塞页面的渲染（Render Tree 依赖 CSSOM）；
- **JS 执行** 也会被 CSS 阻塞（浏览器要等 CSSOM 构建完再执行 JS，避免修改样式导致回流）。

---

> ### ⚙️ 二、如何分析是否阻塞？

1. 打开 **Chrome DevTools → Performance 或 Network 面板**；
2. 查看 CSS 文件加载顺序与阻塞时间；
3. 检查：

   - 是否放在 `<head>`；
   - 是否存在 render-blocking（渲染阻塞）标签；
   - 是否可延迟加载的 CSS。

---

> ### ✅ 1. **关键 CSS 内联**

> 把首屏关键样式直接写在 `<style>` 标签中，减少首屏等待。

```html
<head>
  <style>
    /* 关键部分样式 */
    body {
      font-family: sans-serif;
    }
  </style>
</head>
```

- 只加载必要的样式；
- 非关键部分延迟加载。

---

> ### ✅ 2. **异步加载非关键 CSS**

```html
<link
  rel="preload"
  href="style.css"
  as="style"
  onload="this.rel='stylesheet'"
/>
<noscript><link rel="stylesheet" href="style.css" /></noscript>
```

> `preload` 先加载但不阻塞，`onload` 后再应用。

---

> ### ✅ 3. **分离首屏与非首屏样式**

- 用构建工具（Webpack、Vite）提取关键 CSS；
- 首屏内联，剩余样式延迟加载：

  ```js
  import(/* webpackPrefetch: true */ "./lazy.css");
  ```

---

> ### ✅ 4. **使用媒体查询延迟加载**

```html
<link rel="stylesheet" href="print.css" media="print" />
<link rel="stylesheet" href="mobile.css" media="(max-width: 600px)" />
```

- 只有匹配时才加载，其他情况不会阻塞。

---

> ### ✅ 5. **减少 CSS 文件体积**

- 合并文件、压缩（minify）、去除未使用样式（Tree Shaking）。

---

## 🧠 四、面试简答模板

> CSS 文件是渲染阻塞资源，浏览器需要先加载并解析 CSS 才能构建渲染树。
> 优化方式包括：
>
> 1. 将关键 CSS 内联到 HTML；
> 2. 使用 `preload` 或 `media` 异步加载非关键样式；
> 3. 减少和压缩 CSS 文件体积；
> 4. 利用构建工具提取首屏关键 CSS。

> ### link 和 @import 的区别

- link 是 xhtml 标签，除了引入 css 外，还可以加载库，框架，工具等；@import 属于 css 范畴，只能加载 css
- link 引用 css 的时候，在页面载入时同时加载。 @import 需要页面完全加载完成后加载
- link 是 xhtml 标签，无兼容问题，@import 是 css2 提出来的，低版本的浏览器不支持