下面给你一份**JS 装饰器（Decorators）的基础使用 + 基础知识点**，**只讲核心、好理解、不绕**，适合**刚接触 / 面试 / 看别人代码不懵**的那种程度 👍
（以**当前主流的新标准装饰器写法**为主，不掺太多历史包袱）

---

# 一、什么是 JS 装饰器（一句话版）

> **装饰器 = 给类或类成员“加功能”的语法糖**
> 本质是：**在不改原代码的情况下，对类 / 方法 / 属性做增强**

```js
@log
method() {}
```

可以理解为：
👉 **在定义阶段，React/JS 帮你把这个方法“包一层”**

---

# 二、装饰器能装饰什么（基础版）

JS 装饰器主要能用在 **class 里**：

| 可以装饰            | 示例                     |
| --------------- | ---------------------- |
| 类               | `@sealed class A {}`   |
| 方法              | `@log foo()`           |
| getter / setter | `@readonly get name()` |
| 字段（属性）          | `@required name = ''`  |

❌ **不能装饰函数、变量、if、for**
❌ **参数装饰器**（新标准里没有）

---

# 三、装饰器的基本形态（必会）

### 1️⃣ 装饰器本质是一个函数

```js
function myDecorator(value, context) {
  // value：被装饰的东西
  // context：描述信息
}
```

### 2️⃣ 使用方式

```js
@myDecorator
method() {}
```

---

# 四、最基础的 3 种装饰器写法

## 1️⃣ 方法装饰器（最常见）

### 示例：给方法加日志

```js
function log(value, context) {
  return function (...args) {
    console.log("调用前", args);
    const result = value.apply(this, args);
    console.log("调用后", result);
    return result;
  };
}

class User {
  @log
  getName(name) {
    return "Hello " + name;
  }
}
```

📌 关键点：

* `value` 是 **原方法**
* 返回的新函数会 **替换原方法**
* 非常适合：日志、鉴权、埋点、缓存

---

## 2️⃣ 带参数的装饰器（最常用形态）

```js
function log(prefix) {
  return function (value, context) {
    return function (...args) {
      console.log(prefix, args);
      return value.apply(this, args);
    };
  };
}

class A {
  @log("DEBUG")
  test(x) {
    return x * 2;
  }
}
```

👉 **装饰器 = 高阶函数（函数返回函数）**

---

## 3️⃣ 类装饰器（了解即可）

```js
function sealed(value, context) {
  Object.freeze(value);
  Object.freeze(value.prototype);
}

@sealed
class A {}
```

📌 常见用途：

* 禁止修改类
* 注册到某个容器
* 自动加静态属性

---

# 五、context 里最重要的几个字段（基础）

```js
function demo(value, context) {
  console.log(context.kind); // "class" | "method" | "field"
  console.log(context.name); // 成员名
}
```

| 字段        | 含义    |
| --------- | ----- |
| `kind`    | 装饰的是啥 |
| `name`    | 名字    |
| `static`  | 是否静态  |
| `private` | 是否私有  |

👉 初学阶段：**只用 `kind` 和 `name` 就够了**

---

# 六、执行时机（非常重要）

### ❗ 装饰器不是在调用时执行

而是：

> **在“类定义阶段”执行**

```js
class A {
  @log
  foo() {}
}
```

执行顺序是：

1. JS 解析 class
2. 执行装饰器函数
3. 替换/增强方法
4. 以后每次调用用的是“增强后”的方法

---

# 七、装饰器 vs 普通函数（对比理解）

### 不用装饰器

```js
function log(fn) {
  return function (...args) {
    console.log(args);
    return fn.apply(this, args);
  };
}

obj.foo = log(obj.foo);
```

### 用装饰器

```js
class A {
  @log
  foo() {}
}
```

👉 装饰器只是让这种“包装逻辑”**更优雅、更集中**

---

# 八、最常见的基础使用场景

✅ 日志

```js
@log
```

✅ 防抖 / 节流

```js
@debounce(300)
```

✅ 权限控制

```js
@auth("admin")
```

✅ 缓存

```js
@memo
```

👉 本质：**横切逻辑，不属于业务本身**

---

# 九、初学者必踩的 5 个坑

### 1️⃣ 装饰器不是立即执行

```js
@log
foo() {}
```

不是点按钮才“装饰”，而是 **class 定义时**

---

### 2️⃣ this 丢失

```js
const fn = obj.method; // 可能丢 this
```

解决方案：在装饰器里 `bind(this)`

---

### 3️⃣ 不要用装饰器写业务逻辑

❌ 不清晰
❌ 不好调试
✅ 只做“通用增强”

---

### 4️⃣ 装饰器执行顺序别强依赖

多个装饰器叠加时，不要假设谁先谁后

---

### 5️⃣ 新旧装饰器语法别混

网上很多是 **TypeScript 老装饰器**

```ts
(target, key, descriptor) // ❌ 新标准不用
```

---

# 十、记住这 5 句话就够了（总结）

1️⃣ 装饰器是**语法糖，本质是函数**
2️⃣ 装饰器在 **class 定义时执行**
3️⃣ 方法装饰器 = **包装原方法**
4️⃣ 装饰器适合 **日志 / 鉴权 / 缓存 / 埋点**
5️⃣ 别用装饰器写核心业务逻辑

---

如果你愿意，我可以下一步给你：

* 👉 **5 个最常用装饰器完整实现**
* 👉 **TS / Babel / Vite 的最小可运行配置**
* 👉 **新装饰器 vs TS 老装饰器对比速查表**

你直接告诉我「想继续学哪一个」。
